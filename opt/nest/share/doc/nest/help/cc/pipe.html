<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title>NEST Command Index: pipe</title>
  <style type="text/css">
    body {
      padding: 0;
      margin: 0;
    }
    a {
      color: #339;
      text-decoration: none;
    }
    a:visited {
      color: #339;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    h1 {
      padding: 15px 0 0 15px;
    }
    p {
      padding-left: 15px;
    }
    table.headerfooter {
      margin: 20px 0 20px 0;
      background-color: #eee;
      width: 100%;
      height: 30px;
      border-top: 2px solid #ccc;
      border-bottom: 2px solid #ccc;
      text-align: center;
    }
  </style>
</head>
<body bgcolor="white" fgcolor="black">
<h1>Command: pipe</h1>
 
<table class="headerfooter">
  <tr>
    <td width="30%" align=center><a href="../../index.html">NEST HelpDesk</a></td>
    <td width="30%" align=center><a href="../helpindex.html">Command Index</a></td>
    <td width="30%" align=center><a href="../../quickref.html">NEST Quick Reference</a></td>
  </tr>
</table>

<p>
<table>
<tr><td valign="top"><b>Name:</b></td><td valign="top"><pre> pipe - Open up a pipe

</pre></td></tr><tr><td valign="top"><b>Synopsis:</b></td><td valign="top"><pre> pipe -> read_end write_end

</pre></td></tr><tr><td valign="top"><b>Description:</b></td><td valign="top"><pre>  The pipe function creates a pipe, placing a filestream
             for the read end and a filestream for the write end of
             the pipe on the stack.
              Data can be written to "write_end" and read from "read_end".
             A read on "read_end" accesses the data written to "write_end"
             on a first-in-first-out basis.

</pre></td></tr><tr><td valign="top"><b>Parameters:</b></td><td valign="top"><pre> In : -none-

            Out: read_end(ifstream):
                   A filestream open for reading, connected to the read-
                   end of the newly created pipe.

                 write_end(ofstream):
                   A filestream open for writing, connected to the write-
                   end of the newly created pipe.

</pre></td></tr><tr><td valign="top"><b>Examples:</b></td><td valign="top"><pre> pipe
          (Hello Pipe) <- std::endl
          pop
          getline =

</pre></td></tr><tr><td valign="top"><b>Diagnostics:</b></td><td valign="top"><pre> If a system-error occurs, a code is stored in "sys_errno"
              (contained in errordict) to identify the error, and
              "sys_errname" is set to the error message. Then a
              "SystemError" is raised.

</pre></td></tr><tr><td valign="top"><b>Bugs:</b></td><td valign="top"><pre> -

</pre></td></tr><tr><td valign="top"><b>Author:</b></td><td valign="top"><pre> R Kupper

</pre></td></tr><tr><td valign="top"><b>FirstVersion:</b></td><td valign="top"><pre> May 02 1999

</pre></td></tr><tr><td valign="top"><b>Remarks:</b></td><td valign="top"><pre>  Description-text taken mainly from "POSIX Programmer's Guide",
         D. Lewine, O'Reilly & Assoc. Inc.

          The O_NONBLOCK and FD_CLOEXEC flags are clear on the
         file descriptors of both streams.

          Opening a pipe in a single process is next to useless (however,
         it might be used for buffering data). The usual application
         is for inter-process-communication: A pipe is opened, and fork
         is called. The child process inherits both filestreams from
         the parent. The child will then close one of the streams (say:
         the read-end), the parent will close the other (say: the write-
         end). Data may then be transfered from the child to the parent
         process through the pipe.

          If the child is to "sysexec" a UNIX command, it may duplicate
         the pipes's write-end onto its standard "cout" stream using "dup2",
         thus directing any data written to "cout" into the pipe. It then
         calles "sysexec". The parent process is thus enabled to read
         the UNIX-command's standard output from the pipe.

          Pipes are unidirectional communication channels.
         For bidirectional communication, two separate pipes must be opened.
         The "spawn" command provides this functionality.

<tr><td valign="top"><b>SeeAlso:</b></td><td valign="top"><a href="../sli/dup2.html"><tt>dup2</tt></a>  <a href="../cc/available.html"><tt>available</tt></a>  <a href="../sli/spawn.html"><tt>spawn</tt></a>  </td></tr>

</pre></td></tr> <tr><td valign="top"><b>Source:</b></td><td valign="top"><pre> /home/ubuntu/nest_server_codes/nest-2.8.0/sli/processes.h
</pre></td></tr></table>
</p>

<table class="headerfooter">
  <tr>
    <td width="30%" align=center><a href="../../index.html">NEST HelpDesk</a></td>
    <td width="30%" align=center><a href="../helpindex.html">Command Index</a></td>
    <td width="30%" align=center><a href="../../quickref.html">NEST Quick Reference</a></td>
  </tr>
</table>
<p style="text-align:center">
  &copy; 2004 <a href="http://www.nest-initiative.org">The NEST Initiative</a>
</p>
</body>
</html>
