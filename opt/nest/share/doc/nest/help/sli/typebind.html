<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title>NEST Command Index: typebind</title>
  <style type="text/css">
    body {
      padding: 0;
      margin: 0;
    }
    a {
      color: #339;
      text-decoration: none;
    }
    a:visited {
      color: #339;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    h1 {
      padding: 15px 0 0 15px;
    }
    p {
      padding-left: 15px;
    }
    table.headerfooter {
      margin: 20px 0 20px 0;
      background-color: #eee;
      width: 100%;
      height: 30px;
      border-top: 2px solid #ccc;
      border-bottom: 2px solid #ccc;
      text-align: center;
    }
  </style>
</head>
<body bgcolor="white" fgcolor="black">
<h1>Command: typebind</h1>
 
<table class="headerfooter">
  <tr>
    <td width="30%" align=center><a href="../../index.html">NEST HelpDesk</a></td>
    <td width="30%" align=center><a href="../helpindex.html">Command Index</a></td>
    <td width="30%" align=center><a href="../../quickref.html">NEST Quick Reference</a></td>
  </tr>
</table>

<p>
<table>
<tr><td valign="top"><b>Name:</b></td><td valign="top"><pre> typebind - optimizes procedure for certain data type
</pre></td></tr><tr><td valign="top"><b>Synopsis:</b></td><td valign="top"><pre> proc dict typebind -> proc
                               
</pre></td></tr><tr><td valign="top"><b>Description:</b></td><td valign="top"><pre>
 The operator is called on a procedure and optimizes the function
 calls in this procedure by removing type checking of the overloaded 
 functions according to the information in the dictionary. The dictionary 
 specifies the names of the functions for which the type of the arguments 
 is knon and the expected combination of argument types. typebind uses this 
 information to replace the function calls in the procedure by the appropriate 
 variant. This reduces the number of interpreter cycles required to evaluate
 the procedure. However, the bigger effect is the reduction of run time. 
 The operator typebind can be used to optimize SLI code for speed in
 situations where it is guaranteed that a particular variant of a
 function is needed. Here, replacing the overloaded function by the
 specific variant removes the overhead of type checking. A typical
 situation in which the data types of the arguments are known is a
 function call inside a function with a specified signature (see
 example below). Another situation is machine generated SLI code where
 the machine, for example a compiler, is requested to emit optimized
 code restricted to particular data type.
  
   /incr [/doubletype]
   {
    1.0 add
   } 
   << /add [/doubletype /doubletype] >> typebind 
   def 

 The example below achieves a reduction of interpreter cycles by 20%
 but a reduction of rune time by 60%.

</pre></td></tr><tr><td valign="top"><b>Parameters:</b></td><td valign="top"><pre>
   proc, is the procedure to be optimized
   dict, contains as keys the names of the operators that should
         be constrained to a certain combination of argument types.
         The value associated to the key is an array specifying the
         data type of each argument.

</pre></td></tr><tr><td valign="top"><b>Examples:</b></td><td valign="top"><pre> 

 The following is the closed form expression of a postsynaptic potential at
 at time t

 ( 
   weight * E/tau_syn * 1./C_m 
     * (   (exp(-t/tau_m)-exp(-t/tau_syn)) / (1./tau_syn - 1./tau_m)^2. 
         -        t*exp(-t/tau_syn)        / (1./tau_syn - 1./tau_m) 
      ) 
 )
 CompileMath /v Set

 The expression operates on doubles. Therefore we optimize with

 /v load 
  << 
     /add [/doubletype /doubletype] 
     /sub [/doubletype /doubletype] 
     /mul [/doubletype /doubletype] 
     /div [/doubletype /doubletype] 
     /pow [/doubletype /doubletype] 
     /exp [/doubletype ] 
     /neg [/doubletype ] 
  >> typebind /v_d Set

 We can further optimize by replacing all symbolic constants by the 
 corresponding values

 /v_d load
  << 
    /weight    3.2
    /tau_syn   0.5
    /tau_m    10.0
    /C_m     250.0
    /t         1.345
    /E         E
  >> Inline /v_c Set

 Let us now explore the required number of interpreter cycles and the run time
 of the three versions

 clic v cloc   
 clic v_d cloc 
 clic v_c cloc 
 tic 500000 {v pop}   repeat toc 
 tic 500000 {v_d pop} repeat toc 
 tic 500000 {v_c pop} repeat toc 

 The results are:
                       v    v_d   v_c
   ----------------------------------
   cycles             138   112    97
    reduction factor        1.2   1.4
                            20%   30%
   ----------------------------------
   time               20.8  8.3   6.5
    reduction factor        2.5   3.2
                            60%   69%
   ----------------------------------

</pre></td></tr><tr><td valign="top"><b>Remarks:</b></td><td valign="top"><pre>
 typebind may be implemented by Inline, see the documentation of variant.


</pre></td></tr><tr><td valign="top"><b>Author:</b></td><td valign="top"><pre> Diesmann
</pre></td></tr><tr><td valign="top"><b>FirstVersion:</b></td><td valign="top"><pre> 090210
 
<tr><td valign="top"><b>SeeAlso:</b></td><td valign="top"><a href="../sli/variant.html"><tt>variant</tt></a>  <a href="../sli/Inline.html"><tt>Inline</tt></a>  <a href="../sli/CompileMath.html"><tt>CompileMath</tt></a>  <a href="../sli/def.html"><tt>def</tt></a>  <a href="../sli/clic.html"><tt>clic</tt></a>  <a href="../sli/tic.html"><tt>tic</tt></a>  </td></tr>
</pre></td></tr> <tr><td valign="top"><b>Source:</b></td><td valign="top"><pre> /home/ubuntu/nest_server_codes/nest-2.8.0/lib/sli/typeinit.sli
</pre></td></tr></table>
</p>

<table class="headerfooter">
  <tr>
    <td width="30%" align=center><a href="../../index.html">NEST HelpDesk</a></td>
    <td width="30%" align=center><a href="../helpindex.html">Command Index</a></td>
    <td width="30%" align=center><a href="../../quickref.html">NEST Quick Reference</a></td>
  </tr>
</table>
<p style="text-align:center">
  &copy; 2004 <a href="http://www.nest-initiative.org">The NEST Initiative</a>
</p>
</body>
</html>
